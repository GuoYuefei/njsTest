# 第一个markdown文件
 ---
 >下面来演示表格

 | name | age | tel |
 | --- | --- | --- |
 |wing|22|178\*\***8211|
 |lala|22|123234234|

****
* 无序列表1
  * 无序列表1.1
  * 无序列表1.2
- 无序列表2
+ 无序列表


1. 有序列表1
2. 有序列表2
3. 有序列表3

---


<br/>

<code>    //行代码
<br/> 换行
</code>

<pre><code>
这里可以使用多段代码
也可以自由换行
</code></pre>



---

> 引用1
> 引用2
>> 引用2.1
>>>引用2.1.1
>
> 跳出上一个得空一行


 ---

 * [x] ok
 * [ ] not finish

![雷峰塔](https://timgsa.baidu.com/timg?image&quality=80&size=b9999_10000&sec=1490114463772&di=3f8f72764fa52076214a8fe874e90db7&imgtype=0&src=http%3A%2F%2Fh.hiphotos.baidu.com%2Flvpics%2Fh%3D800%2Fsign%3Da9467f17ff1f4134ff37087e151e95c1%2F9f510fb30f2442a7d66b1f51d343ad4bd01302d8.jpg =512x300)

[百度首页](https://www.baidu.com)

---
~~删除线删除线删除线~~
## 黑体 ##
*斜体*

__下划线 __

----

```

/* Main.c file generated by New Project wizard
 *
 * Created:   周一 6月 19 2017
 * Processor: 80C51
 * Compiler:  Keil for 8051
 */

#include <reg51.h>
#include <stdio.h>
#define uint unsigned int;
#define uchar unsigned char;
/**
* 以下的量是用于数码管的片选信号，其中只有week是高电平有效
*/
sbit h1 = P1^0;
sbit h0 = P1^1;
sbit m1 = P1^2;
sbit m0 = P1^3;
sbit s1 = P1^4;
sbit s0 = P1^5;
sbit weekable = P1^6;

sbit timerOut0 = P1^7;
/**
*	以下键盘监听用的变量
*/
sbit p2_0 = P2^0;
sbit p2_1 = P2^1;
sbit p2_2 = P2^2;
sbit p2_3 = P2^3;
sbit p2_4 = P2^4;
sbit p2_5 = P2^5;
sbit p2_6 = P2^6;

sbit p2_7 = P2^7;


sbit alarm = P3^7;

uchar code DIS_CODE[]={0x3f,0x06,0x5b,0x4f,0x66,0x6d,0x7d,0x07,0x7f,0x6f};
uchar code T = 10;
char keyFlag=0;
char alarmFlag=0;   //是否启动闹钟

uchar h,m,s,week;			//声明数值
uchar alarmH,alarmM,alarmS;		//闹钟时间



/**
*  函数声明部分
*/
void plusOne();			//时间加一函数
void display();			//时间显示
void weekshow();		//显示星期，用了锁存，所以与display分离
void delay(char i);		//延时
void init_timer();		//定时器初始化
void init_timer0();		//针对timer0的初始化
void init_timer1();		//针对timer1的初始化
void init_keypad();		//键盘初始化
char listen();			//监听键盘
void afterListen(char flag);	//在监听键盘后的处理，flag是listen的返回值
void init_INT0();		//外部中断的初始化
void judgeAlarm();		//判断闹钟函数
void initDATA();		//总的一个初始化
void displayAlarm();		//显示闹钟时间函数
void alarmStart();		//闹钟开始
void alarmStop();		//闹钟结束
char isStarted();		//判断闹钟是否执行中

void main(void)
 {
   // Write your code here

   initDATA();
   weekshow();
   init_timer();
   init_timer0();
   init_timer1();
   init_keypad();
   init_INT0();


   while (1){
      display();
      keyFlag=listen();
      afterListen(keyFlag);
   }
 }

 void initDATA(){
   weekable=0;		//初始化为了，锁存
   //now part
   h=0;
   m=0;
   s=0;
   week=0;
   //alarm part
   alarmH=0;
   alarmM=0;
   alarmS=0;
   alarm=1;		//初始GAO电平

 }

 /**
 *	这是一个数码管数值整体加1的函数
 */
 void PlusOne(){
    if(s!=59){
       s++;
    }else{
      s=0;
      if(m!=59){
	m++;
      }else{
	m=0;
	 if(h!=23){
	    h++;
	 }else{
	    h=0;
	    if(week!=6){
	       week++;
	    }else{
	       week=0;
	    }
	    weekshow();
	 }
      }  
    }
}

/**
*	数码管显示函数 除了那个week的数码管以外，因为这个我用了锁存器
*/
void display(){
   P0 = DIS_CODE[h/10];		//显示h1
   h1 = 0;			//显示h1开
   delay(T);
   h1=1;

   P0 = DIS_CODE[h%10];		//显示h0
   h0 = 0;			//显示h0开
   delay(T);
   h0=1;

   P0 = DIS_CODE[m/10];		//显示m1
   m1 = 0;			//显示m1开
   delay(T);
   m1=1;

   P0 = DIS_CODE[m%10];		//显示m0
   m0 = 0;			//显示m0开
   delay(T);
   m0=1;

   P0 = DIS_CODE[s/10];		//显示s1
   s1 = 0;			//显示s1开
   delay(T);
   s1=1;

   P0 = DIS_CODE[s%10];		//显示s0
   s0 = 0;			//显示s0开
   delay(T);
   s0=1;
}

/**
*	显示week的函数
*/
void weekshow(){
   P0 = DIS_CODE[week];
   weekable = 1;		//锁存放行数据
   weekable = 0;
}


//简单的延时函数
void delay(char i){
   while(i--){
      char k = i;
      while(k--);
  }
}

/**初始化timer timer0工作在1，timer1工作在2————自动重装8位计数  分开函数，满足单一职责的设计方式
*	这里我利用两个定时器配合，0做定时，1做计数配合产生1秒时间，
*	并且0的中断函数里还向24c02中保存数据！！！！！！！
*
*/
void init_timer(){
   TMOD = 0x61;
   EA=1;
   ET0=1;
   ET1=1;
}
//这个函数要控制定时器每过50MS中断一次,那么计数器1要计数10次，因为每100ms一个脉冲
void init_timer0(){
   TH0=(65536-50000)/256;
   TL0=(65536-50000)%256;
   TR0=1;		//启动timer0
}
//这个负责计数10次
void init_timer1(){
   TH1=246;
   TL1=246;
   TR1=1;		//启动timer1
}

/**
*	两个timer的中断函数
*/
void timer0() interrupt 1{
   TH0=(65536-50000)/256;
   TL0=(65536-50000)%256;
   timerOut0=~timerOut0;			//脉冲
}
//计数器
void timer1() interrupt 3{
   plusOne();		//数值整体+1
   judgeAlarm();			//检查闹钟

}




/**************************************键盘部分*********************************************/

void init_keypad(){
   P2 = 0xff;
}

//给listen调用，减少代码量的
void aa(char* flag){
   if(~p2_3){
      *flag+=10;
   }else if(~p2_4){
      *flag+=20;
   }else if(~p2_5){
      *flag+=30;
   }else if(~p2_6){
      *flag+=40;
   }else{
      *flag=0;		//假设不成立
   }
}

/**
*	不一样的代码，只为创新，就是不用书上的代码。。。来咬我啊。。。调皮了
*/
char listen(){
   char flag=0;
   if(flag==0){
      p2_0=0;		//假设在第一列
      flag = 1;
      aa(&flag);
      p2_0=1;
   }
   if(flag==0){
      p2_1=0;		//假设在第二列
      flag=2;
      aa(&flag);
      p2_1=1;
   }
   if(flag==0){
      p2_2=0;		//假设在第三列
      flag=3;
      aa(&flag);
      p2_2=1;
   }
   //这时候flag中十位表行，个位表列
   return flag;

}

//解析flag
char parseFlag(char flag){
   char result=-1;
   switch(flag){
      case 11:
	 result=1;
	 break;
      case 12:
	 result=2;
	 break;
      case 13:
	 result=3;
	 break;
      case 21:
	 result=4;
	 break;
      case 22:
	 result=5;
	 break;
      case 23:
	 result=6;
	 break;
      case 31:
	 result=7;
	 break;
      case 32:
	 result=8;
	 break;
      case 33:
	 result=9;
	 break;
      case 42:
	 result=0;
	 break;
      default:
	 result=-1;
   }
   return result;			//解析结果返回，如果是#和*就返回-1

}

//得到return数据后
void afterListen(char flag){
   if(isStarted()&&flag!=0){		//如果闹钟在响铃状态的话
      alarmStop();		//按任意键关闭闹钟
      return;			//取消对后面事件的监听
   }
   switch(flag){
      case 41:
	 p2_7 = 0;   	//触发外部中断
	 break;
      case 43:
	 p2_7 = 0;
	 break;
   }
}

//外部中断初始化
void init_INT0(){

   EX0=1;
   IT0=1;			//边沿触发方式

}

/**
* 显示闹钟的设置时间
*/

void displayAlarm(){
   P0 = DIS_CODE[alarmH/10];		//显示h1
   h1 = 0;			//显示h1开
   delay(T);
   h1=1;

   P0 = DIS_CODE[alarmH%10];		//显示h0
   h0 = 0;			//显示h0开
   delay(T);
   h0=1;

   P0 = DIS_CODE[alarmM/10];		//显示m1
   m1 = 0;			//显示m1开
   delay(T);
   m1=1;

   P0 = DIS_CODE[alarmM%10];		//显示m0
   m0 = 0;			//显示m0开
   delay(T);
   m0=1;

   P0 = DIS_CODE[alarmS/10];		//显示s1
   s1 = 0;			//显示s1开
   delay(T);
   s1=1;

   P0 = DIS_CODE[alarmS%10];		//显示s0
   s0 = 0;			//显示s0开
   delay(T);
   s0=1;
}

//用最高级别的中断  注意在设置闹钟时需要拉高timer的中断优先级
void exINT0() interrupt 0 {
   char count = 7;
   char temp=-1;
   char what=0;
	 if(keyFlag==41){			//如果是因为*键促发的，那么就调时模式
	    while(1){
	       display();
	       what = listen();			//没有监听到，返回0
	       while(what==temp){
		  what = listen();
		  display();
	       }
	       temp = what;
	       if(what!=0&&what!=41&&what!=43){					//监听到了
		  switch(count--){
		  case 7:
		     week=parseFlag(what)%7;weekshow();break;
		  case 6:
		     h=0;
		     h+=parseFlag(what)%3*10;break;
		  case 5:
		     h+=parseFlag(what);
		     break;
		  case 4:
		     m=0;
		     m+=parseFlag(what)%6*10;break;
		  case 3:
		     m+=parseFlag(what);
		     break;
		  case 2:
		     s=0;
		     s+=parseFlag(what)%6*10;break;
		  case 1:
		     s+=parseFlag(what);
		  default:
		     p2_7=1;
		     keyFlag=0;
		     return;
		  }
	       }
	    }
	 }else{				//如果是因为#号促发，那么设置闹钟
	    //////先空着，以后写
	    count=6;			//闹钟只要设置6位
	    //提高定时器中断请求的优先级  这是为了才设置过程也能正常计时
	    PT0=1;
	    PT1=1;
	    while(1){
	       displayAlarm();
	       what = listen();			//没有监听到，返回0
	       while(what==temp){
		  what = listen();
		  displayAlarm();
	       }
	       temp = what;
	       if(what!=0&&what!=41&&what!=43){					//监听到了
		  switch(count--){
		  case 6:
		     alarmH=0;
		     alarmH+=parseFlag(what)%3*10;break;
		  case 5:
		     alarmH+=parseFlag(what);
		     break;
		  case 4:
		     alarmM=0;
		     alarmM+=parseFlag(what)%6*10;break;
		  case 3:
		     alarmM+=parseFlag(what);
		     break;
		  case 2:
		     alarmS=0;
		     alarmS+=parseFlag(what)%6*10;break;
		  case 1:
		     alarmS+=parseFlag(what);break;		//这里加break是为了确定闹钟值
		  default:
		     p2_7=1;
		     keyFlag=0;
		     alarmFlag=1;		//开启闹钟
		     //还原优先级
		     PT1=0;
		     PT0=0;		
		     return;
		  }
	       }
	    }

	 }
   }

/******************************闹钟模块**********************************/
//发声用的

void alarmStart(){
   alarm = 0;
}

//停止发声
void alarmStop(){
   alarm = 1;
}
//判定是否启动闹钟
char isStarted(){
   if(alarm==0){
      return 1;
   }else{
      return 0;
   }
}

//判定是否到达预定时间		这个过程，我使用timer1不断监听该事件
void judgeAlarm(){
   if(alarmFlag==1&&h==alarmH&&m==alarmM&&s==alarmS){		//到达时间就发生事件
      alarmStart();
      alarmFlag = 0;			//关闭闹钟标志，但实际上闹钟一直促发的
   } 
}


/******************************断电保持模块***************************************/







```
